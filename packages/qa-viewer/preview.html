<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Sprite Factory 3D Preview</title>
    <style>
      :root { --bg:#0b0d10; --fg:#e8eef6; --muted:#9fb3c8; --accent:#70b0ff; --success:#22c55e; --warning:#f59e0b; --error:#ef4444; }
      html, body { height: 100%; margin: 0; overflow: hidden; }
      body { font-family: system-ui, sans-serif; background: var(--bg); color: var(--fg); }
      
      .container { display: flex; height: 100vh; }
      .sidebar { width: 320px; background: #12161d; border-right: 1px solid #1e2732; padding: 20px; overflow-y: auto; }
      .viewport { flex: 1; position: relative; }
      
      h1, h2, h3 { color: var(--accent); margin-top: 0; }
      h1 { font-size: 18px; }
      h2 { font-size: 16px; }
      h3 { font-size: 14px; }
      
      .form-group { margin: 15px 0; }
      label { display: block; margin-bottom: 5px; color: var(--muted); font-weight: 500; font-size: 12px; }
      select, button { 
        width: 100%; padding: 8px 12px; background: #0f1419; border: 1px solid #1e2732; 
        border-radius: 6px; color: var(--fg); font-size: 12px; box-sizing: border-box;
      }
      button { 
        background: var(--accent); color: white; cursor: pointer; margin: 5px 0;
      }
      button:hover { opacity: 0.9; }
      button:disabled { opacity: 0.5; cursor: not-allowed; }
      
      .status { 
        padding: 8px 12px; border-radius: 6px; margin: 10px 0; font-weight: 500; font-size: 12px;
        border-left: 4px solid;
      }
      .status.success { background: rgba(34, 197, 94, 0.1); border-color: var(--success); color: var(--success); }
      .status.warning { background: rgba(245, 158, 11, 0.1); border-color: var(--warning); color: var(--warning); }
      .status.error { background: rgba(239, 68, 68, 0.1); border-color: var(--error); color: var(--error); }
      
      .nav { margin-bottom: 20px; }
      .nav a { color: var(--accent); text-decoration: none; margin-right: 15px; font-size: 12px; }
      .nav a:hover { text-decoration: underline; }
      
      .controls { background: #0a0f14; border: 1px solid #1e2732; border-radius: 6px; padding: 15px; margin: 15px 0; }
      .controls h3 { margin-top: 0; }
      
      .asset-list { font-size: 11px; }
      .asset-item { padding: 4px 8px; margin: 2px 0; border-radius: 4px; background: #0f1419; }
      .asset-item.missing { background: #2d1b1b; color: #ef4444; }
      .asset-item.found { background: #1b2d1f; color: #22c55e; }
      
      .loading-overlay {
        position: absolute; top: 0; left: 0; right: 0; bottom: 0;
        background: rgba(11, 13, 16, 0.8); display: flex; align-items: center; justify-content: center;
        flex-direction: column; z-index: 1000;
      }
      
      .spinner {
        width: 40px; height: 40px; border: 4px solid #1e2732;
        border-top: 4px solid var(--accent); border-radius: 50%; animation: spin 1s linear infinite;
      }
      @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
      
      #viewport { width: 100%; height: 100%; }
      
      .camera-controls { 
        position: absolute; top: 10px; right: 10px; background: rgba(18, 22, 29, 0.9); 
        padding: 10px; border-radius: 6px; font-size: 11px; color: var(--muted);
      }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/fflate@0.7.4/umd/index.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/FBXLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  </head>
  <body>
    <div class="container">
      <div class="sidebar">
        <div class="nav">
          <a href="/">← QA Viewer</a>
          <a href="/build.html">Build</a>
          <a href="/preview.html">3D Preview</a>
        </div>
        
        <h1>3D Model Preview</h1>
        
        <div class="form-group">
          <label>Character:</label>
          <select id="characterSelect">
            <option value="samples/characters/warrior.json">Warrior</option>
          </select>
        </div>
        
        <button id="loadModel">Load Model</button>
        
        <div id="status"></div>
        
        <div class="controls">
          <h3>View Controls</h3>
          <button id="resetCamera">Reset Camera</button>
          <button id="toggleWireframe">Toggle Wireframe</button>
          
          <div class="form-group">
            <label>Background:</label>
            <select id="backgroundSelect">
              <option value="dark">Dark</option>
              <option value="light">Light</option>
              <option value="grid">Grid</option>
            </select>
          </div>
        </div>
        
        <div class="controls">
          <h3>Animation Controls</h3>
          <div class="form-group">
            <label>Animation:</label>
            <select id="animationSelect" disabled>
              <option value="">No animations loaded</option>
            </select>
          </div>
          <button id="playAnimation" disabled>Play</button>
          <button id="pauseAnimation" disabled>Pause</button>
          <button id="stopAnimation" disabled>Stop</button>
          
          <div class="form-group">
            <label>Speed:</label>
            <input type="range" id="animationSpeed" min="0.1" max="3" step="0.1" value="1" disabled style="width: 100%;">
            <span id="speedValue">1.0x</span>
          </div>
        </div>
        
        <div class="controls">
          <h3>Model Info</h3>
          <div id="modelInfo">No model loaded</div>
        </div>
        
        <div class="controls">
          <h3>Assets Status</h3>
          <div id="assetStatus" class="asset-list">Click "Load Model" to check assets</div>
        </div>
      </div>
      
      <div class="viewport">
        <div id="viewport"></div>
        <div class="camera-controls">
          <strong>Camera Controls:</strong><br>
          Left click: Rotate<br>
          Right click: Pan<br>
          Scroll: Zoom
        </div>
        <div id="loadingOverlay" class="loading-overlay" style="display: none;">
          <div class="spinner"></div>
          <p style="margin-top: 20px;">Loading 3D model...</p>
        </div>
      </div>
    </div>

    <script>
      let scene, camera, renderer, controls, model, mixer, clock;
      let currentCharacter = null;
      let animations = [];
      let currentAction = null;
      
      const ui = {
        characterSelect: document.getElementById('characterSelect'),
        loadModel: document.getElementById('loadModel'),
        status: document.getElementById('status'),
        modelInfo: document.getElementById('modelInfo'),
        assetStatus: document.getElementById('assetStatus'),
        resetCamera: document.getElementById('resetCamera'),
        toggleWireframe: document.getElementById('toggleWireframe'),
        backgroundSelect: document.getElementById('backgroundSelect'),
        animationSelect: document.getElementById('animationSelect'),
        playAnimation: document.getElementById('playAnimation'),
        pauseAnimation: document.getElementById('pauseAnimation'),
        stopAnimation: document.getElementById('stopAnimation'),
        animationSpeed: document.getElementById('animationSpeed'),
        speedValue: document.getElementById('speedValue'),
        viewport: document.getElementById('viewport'),
        loadingOverlay: document.getElementById('loadingOverlay')
      };

      function showStatus(message, type = 'success') {
        ui.status.innerHTML = `<div class="status ${type}">${message}</div>`;
      }

      function initThreeJS() {
        // Scene
        scene = new THREE.Scene();
        
        // Camera
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 1.6, 3);
        
        // Renderer
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(ui.viewport.offsetWidth, ui.viewport.offsetHeight);
        renderer.setClearColor(0x0b0d10);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        ui.viewport.appendChild(renderer.domElement);
        
        // Controls
        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.target.set(0, 1, 0);
        
        // Lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(5, 10, 5);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.setScalar(2048);
        scene.add(directionalLight);
        
        const fillLight = new THREE.DirectionalLight(0x4488ff, 0.3);
        fillLight.position.set(-5, 5, -5);
        scene.add(fillLight);
        
        // Ground plane
        const groundGeometry = new THREE.PlaneGeometry(10, 10);
        const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x1a1f26 });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);
        
        // Clock for animations
        clock = new THREE.Clock();
        
        // Resize handler
        window.addEventListener('resize', onWindowResize);
        
        animate();
      }

      function onWindowResize() {
        camera.aspect = ui.viewport.offsetWidth / ui.viewport.offsetHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(ui.viewport.offsetWidth, ui.viewport.offsetHeight);
      }

      function animate() {
        requestAnimationFrame(animate);
        
        controls.update();
        
        if (mixer) {
          mixer.update(clock.getDelta());
        }
        
        renderer.render(scene, camera);
      }

      async function inspectCharacter(characterPath) {
        try {
          const response = await fetch('/api/content/inspect', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ characterPath })
          });
          
          const result = await response.json();
          
          if (result.success) {
            currentCharacter = result;
            updateAssetStatus(result.assets);
            return result;
          } else {
            throw new Error(result.message || 'Failed to inspect character');
          }
        } catch (error) {
          showStatus(`Inspection failed: ${error.message}`, 'error');
          return null;
        }
      }

      function updateAssetStatus(assets) {
        let html = '';
        
        if (assets.rig) {
          const status = assets.rig.exists ? 'found' : 'missing';
          const icon = assets.rig.exists ? '✅' : '❌';
          html += `<div class="asset-item ${status}">${icon} Rig: ${assets.rig.path}</div>`;
        }
        
        for (const anim of assets.animations) {
          const status = anim.exists ? 'found' : 'missing';
          const icon = anim.exists ? '✅' : '❌';
          html += `<div class="asset-item ${status}">${icon} ${anim.name} (${anim.frames}f)</div>`;
        }
        
        for (const tex of assets.textures) {
          const status = tex.exists ? 'found' : 'missing';
          const icon = tex.exists ? '✅' : '❌';
          html += `<div class="asset-item ${status}">${icon} ${tex.type}</div>`;
        }
        
        for (const equip of assets.equipment) {
          const status = equip.exists ? 'found' : 'missing';
          const icon = equip.exists ? '✅' : '❌';
          html += `<div class="asset-item ${status}">${icon} ${equip.mount}</div>`;
        }
        
        ui.assetStatus.innerHTML = html || 'No assets found';
      }

      async function loadModel() {
        const characterPath = ui.characterSelect.value;
        
        showStatus('Inspecting character...', 'warning');
        ui.loadingOverlay.style.display = 'flex';
        
        const characterData = await inspectCharacter(characterPath);
        if (!characterData) return;
        
        // Clear previous model
        if (model) {
          scene.remove(model);
          model = null;
        }
        if (mixer) {
          mixer = null;
        }
        
        if (!characterData.assets.rig || !characterData.assets.rig.exists) {
          showStatus('No rig file found', 'error');
          ui.loadingOverlay.style.display = 'none';
          return;
        }
        
        showStatus('Loading 3D model...', 'warning');
        
        try {
          const rigPath = `/content/rigs/${characterData.assets.rig.path.split('/').pop()}`;
          console.log('Loading model from:', rigPath);
          
          if (rigPath.endsWith('.fbx')) {
            console.log('Using FBXLoader...');
            const loader = new THREE.FBXLoader();
            model = await new Promise((resolve, reject) => {
              loader.load(
                rigPath, 
                (object) => {
                  console.log('FBX loaded successfully:', object);
                  resolve(object);
                },
                (progress) => {
                  console.log('Loading progress:', progress);
                },
                (error) => {
                  console.error('FBX loading error:', error);
                  reject(error);
                }
              );
            });
          } else if (rigPath.endsWith('.glb') || rigPath.endsWith('.gltf')) {
            console.log('Using GLTFLoader...');
            const loader = new THREE.GLTFLoader();
            const gltf = await new Promise((resolve, reject) => {
              loader.load(
                rigPath, 
                (gltf) => {
                  console.log('GLTF loaded successfully:', gltf);
                  resolve(gltf);
                },
                (progress) => {
                  console.log('Loading progress:', progress);
                },
                (error) => {
                  console.error('GLTF loading error:', error);
                  reject(error);
                }
              );
            });
            model = gltf.scene;
          } else {
            throw new Error('Unsupported model format');
          }
          
          // Setup model
          model.scale.setScalar(0.01); // Scale down if needed
          model.traverse(child => {
            if (child.isMesh) {
              child.castShadow = true;
              child.receiveShadow = true;
            }
          });
          
          scene.add(model);
          
          // Setup animation mixer
          mixer = new THREE.AnimationMixer(model);
          
          if (model.animations && model.animations.length > 0) {
            console.log('Found embedded animations in rig:', model.animations);
            animations = [...model.animations]; // Copy embedded animations
            
            // Map animation names to more readable names if possible
            animations.forEach((anim, index) => {
              console.log(`Embedded Animation ${index}: "${anim.name}" (duration: ${anim.duration}s)`);
              
              // Try to map generic names to specific animation types
              if (anim.name.toLowerCase().includes('walk') || anim.name.includes('Walk')) {
                anim.displayName = 'walk (embedded)';
              } else if (anim.name.toLowerCase().includes('run') || anim.name.includes('Run')) {
                anim.displayName = 'run (embedded)';
              } else if (anim.name.toLowerCase().includes('attack') || anim.name.includes('Attack')) {
                anim.displayName = 'attack_slash (embedded)';
              } else if (anim.name.toLowerCase().includes('hit') || anim.name.includes('Hit')) {
                anim.displayName = 'hit (embedded)';
              } else if (anim.name.toLowerCase().includes('die') || anim.name.toLowerCase().includes('death')) {
                anim.displayName = 'die (embedded)';
              } else {
                anim.displayName = `${anim.name || `Animation ${index + 1}`} (embedded)`;
              }
              anim.isEmbedded = true;
            });
          } else {
            console.log('No embedded animations found in rig');
            animations = [];
          }
          
          // Always try to load additional separate animation files
          console.log('Loading additional asset-defined animations...');
          await loadAnimations(characterData);
          
          // Update model info
          let info = `<strong>${characterData.character.name}</strong><br>`;
          info += `Vertices: ${getVertexCount(model)}<br>`;
          info += `Materials: ${getMaterialCount(model)}<br>`;
          info += `Bones: ${getBoneCount(model)}<br>`;
          info += `Animations: ${animations.length}`;
          ui.modelInfo.innerHTML = info;
          
          showStatus('Model loaded successfully!', 'success');
          
        } catch (error) {
          showStatus(`Failed to load model: ${error.message}`, 'error');
          console.error('Model loading error:', error);
        }
        
        ui.loadingOverlay.style.display = 'none';
      }

      function getVertexCount(object) {
        let count = 0;
        object.traverse(child => {
          if (child.isMesh && child.geometry) {
            count += child.geometry.attributes.position.count;
          }
        });
        return count.toLocaleString();
      }

      function getMaterialCount(object) {
        const materials = new Set();
        object.traverse(child => {
          if (child.isMesh && child.material) {
            if (Array.isArray(child.material)) {
              child.material.forEach(mat => materials.add(mat.uuid));
            } else {
              materials.add(child.material.uuid);
            }
          }
        });
        return materials.size;
      }

      function getBoneCount(object) {
        let boneCount = 0;
        object.traverse(child => {
          if (child.isBone) boneCount++;
        });
        return boneCount;
      }

      async function loadAnimations(characterData) {
        if (!characterData.assets.animations || !mixer) {
          console.log('No animations to load or mixer not ready');
          return;
        }
        
        console.log('Available animations:', characterData.assets.animations);
        
        try {
          for (const animAsset of characterData.assets.animations) {
            console.log(`Processing animation: ${animAsset.name}, exists: ${animAsset.exists}`);
            
            if (!animAsset.exists) {
              console.log(`Skipping missing animation: ${animAsset.name}`);
              continue;
            }
            
            const animPath = `/content/anims/${animAsset.path.split('/').pop()}`;
            console.log('Loading animation from:', animPath);
            
            try {
              if (animPath.endsWith('.fbx')) {
                const loader = new THREE.FBXLoader();
                const animObject = await new Promise((resolve, reject) => {
                  loader.load(
                    animPath, 
                    (object) => {
                      console.log(`Animation loaded: ${animAsset.name}`, object);
                      resolve(object);
                    },
                    (progress) => {
                      console.log(`Loading ${animAsset.name}:`, progress.loaded / progress.total * 100, '%');
                    },
                    (error) => {
                      console.error(`Failed to load ${animAsset.name}:`, error);
                      reject(error);
                    }
                  );
                });
                
                if (animObject.animations && animObject.animations.length > 0) {
                  console.log(`Found ${animObject.animations.length} animation clips in ${animAsset.name}`);
                  animObject.animations.forEach((anim, index) => {
                    // Set display name and mark as asset-defined
                    anim.displayName = animAsset.name;
                    anim.originalName = anim.name;
                    anim.isEmbedded = false;
                    anim.assetInfo = animAsset;
                    
                    animations.push(anim);
                    console.log(`Added asset animation: ${animAsset.name} (duration: ${anim.duration}s)`);
                  });
                } else {
                  console.warn(`No animation data found in ${animAsset.name}`);
                }
              }
            } catch (animError) {
              console.error(`Error loading ${animAsset.name}:`, animError);
            }
          }
          
          console.log(`Total animations loaded: ${animations.length}`);
          
          // Always set up controls - either with real animations or placeholders
          if (animations.length > 0) {
            setupAnimationControls();
            const embeddedCount = animations.filter(a => a.isEmbedded).length;
            const assetCount = animations.filter(a => !a.isEmbedded).length;
            showStatus(`Loaded ${animations.length} animations (${embeddedCount} embedded, ${assetCount} from assets)`, 'success');
          } else {
            // Create placeholder animations based on character data
            createPlaceholderAnimations(characterData);
          }
        } catch (error) {
          console.error('Animation loading error:', error);
          showStatus('Animation loading failed', 'error');
        }
      }

      function createPlaceholderAnimations(characterData) {
        console.log('Creating placeholder animations...');
        
        // Create basic placeholder animations based on character animation data
        ui.animationSelect.innerHTML = '<option value="">Select animation...</option>';
        
        if (characterData.assets.animations && characterData.assets.animations.length > 0) {
          characterData.assets.animations.forEach((animAsset, index) => {
            const option = document.createElement('option');
            option.value = index;
            option.textContent = `${animAsset.name} (${animAsset.exists ? 'placeholder' : 'missing'})`;
            if (!animAsset.exists) {
              option.style.color = '#ef4444';
              option.disabled = true;
            }
            ui.animationSelect.appendChild(option);
          });
          
          showStatus('Animation files not loaded - showing placeholders', 'warning');
        } else {
          ui.animationSelect.innerHTML = '<option value="">No animations defined</option>';
          showStatus('No animations defined in character', 'error');
        }
        
        // Enable basic controls
        ui.animationSelect.disabled = false;
        ui.playAnimation.disabled = true;
        ui.pauseAnimation.disabled = true;
        ui.stopAnimation.disabled = true;
        ui.animationSpeed.disabled = true;
      }

      function setupAnimationControls() {
        console.log('Setting up animation controls for', animations.length, 'animations');
        
        // Populate animation dropdown
        ui.animationSelect.innerHTML = '<option value="">Select animation...</option>';
        animations.forEach((anim, index) => {
          const option = document.createElement('option');
          option.value = index;
          option.textContent = anim.displayName || anim.name || `Animation ${index + 1}`;
          ui.animationSelect.appendChild(option);
          console.log(`Added to dropdown: ${option.textContent}`);
        });
        
        // Enable controls
        ui.animationSelect.disabled = false;
        ui.playAnimation.disabled = false;
        ui.pauseAnimation.disabled = false;
        ui.stopAnimation.disabled = false;
        ui.animationSpeed.disabled = false;
        
        console.log('Animation controls enabled');
      }

      function playSelectedAnimation() {
        const selectedIndex = ui.animationSelect.value;
        if (selectedIndex === '' || !mixer || !animations[selectedIndex]) return;
        
        // Stop current action
        if (currentAction) {
          currentAction.stop();
        }
        
        // Create and play new action
        const animation = animations[selectedIndex];
        currentAction = mixer.clipAction(animation);
        currentAction.setLoop(THREE.LoopRepeat);
        currentAction.timeScale = parseFloat(ui.animationSpeed.value);
        currentAction.play();
        
        showStatus(`Playing: ${animation.name || 'Animation'}`, 'success');
      }

      function pauseAnimation() {
        if (currentAction && currentAction.isRunning()) {
          currentAction.paused = !currentAction.paused;
          showStatus(currentAction.paused ? 'Animation paused' : 'Animation resumed', 'success');
        }
      }

      function stopAnimation() {
        if (currentAction) {
          currentAction.stop();
          showStatus('Animation stopped', 'success');
        }
      }

      function updateAnimationSpeed() {
        const speed = parseFloat(ui.animationSpeed.value);
        ui.speedValue.textContent = speed.toFixed(1) + 'x';
        if (currentAction) {
          currentAction.timeScale = speed;
        }
      }

      // Event listeners
      ui.loadModel.addEventListener('click', loadModel);
      
      ui.resetCamera.addEventListener('click', () => {
        camera.position.set(0, 1.6, 3);
        controls.target.set(0, 1, 0);
        controls.update();
      });
      
      ui.toggleWireframe.addEventListener('click', () => {
        if (model) {
          model.traverse(child => {
            if (child.isMesh && child.material) {
              if (Array.isArray(child.material)) {
                child.material.forEach(mat => mat.wireframe = !mat.wireframe);
              } else {
                child.material.wireframe = !child.material.wireframe;
              }
            }
          });
        }
      });
      
      ui.backgroundSelect.addEventListener('change', (e) => {
        switch (e.target.value) {
          case 'dark':
            renderer.setClearColor(0x0b0d10);
            break;
          case 'light':
            renderer.setClearColor(0xf0f0f0);
            break;
          case 'grid':
            renderer.setClearColor(0x1a1f26);
            break;
        }
      });
      
      // Animation controls
      ui.animationSelect.addEventListener('change', playSelectedAnimation);
      ui.playAnimation.addEventListener('click', playSelectedAnimation);
      ui.pauseAnimation.addEventListener('click', pauseAnimation);
      ui.stopAnimation.addEventListener('click', stopAnimation);
      ui.animationSpeed.addEventListener('input', updateAnimationSpeed);
      
      // Initialize
      initThreeJS();
      showStatus('Ready to preview 3D models', 'success');
    </script>
  </body>
</html>