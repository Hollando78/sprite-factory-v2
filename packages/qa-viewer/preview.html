<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Sprite Factory 3D Preview</title>
    <style>
      :root { --bg:#0b0d10; --fg:#e8eef6; --muted:#9fb3c8; --accent:#70b0ff; --success:#22c55e; --warning:#f59e0b; --error:#ef4444; }
      html, body { height: 100%; margin: 0; overflow: hidden; }
      body { font-family: system-ui, sans-serif; background: var(--bg); color: var(--fg); }
      
      .container { display: flex; height: 100vh; }
      .sidebar { width: 320px; min-width: 320px; flex-shrink: 0; background: #12161d; border-right: 1px solid #1e2732; padding: 20px; overflow-y: auto; }
      .viewport { flex: 1; position: relative; min-width: 0; }
      .right-sidebar { width: 380px; min-width: 380px; flex-shrink: 0; background: #12161d; border-left: 1px solid #1e2732; padding: 15px; overflow-y: auto; max-height: 100vh; }
      
      h1, h2, h3 { color: var(--accent); margin-top: 0; }
      h1 { font-size: 18px; }
      h2 { font-size: 16px; }
      h3 { font-size: 14px; }
      
      .form-group { margin: 15px 0; }
      label { display: block; margin-bottom: 5px; color: var(--muted); font-weight: 500; font-size: 12px; }
      select, button { 
        width: 100%; padding: 8px 12px; background: #0f1419; border: 1px solid #1e2732; 
        border-radius: 6px; color: var(--fg); font-size: 12px; box-sizing: border-box;
      }
      button { 
        background: var(--accent); color: white; cursor: pointer; margin: 5px 0;
      }
      button:hover { opacity: 0.9; }
      button:disabled { opacity: 0.5; cursor: not-allowed; }
      
      .status { 
        padding: 8px 12px; border-radius: 6px; margin: 10px 0; font-weight: 500; font-size: 12px;
        border-left: 4px solid;
      }
      .status.success { background: rgba(34, 197, 94, 0.1); border-color: var(--success); color: var(--success); }
      .status.warning { background: rgba(245, 158, 11, 0.1); border-color: var(--warning); color: var(--warning); }
      .status.error { background: rgba(239, 68, 68, 0.1); border-color: var(--error); color: var(--error); }
      
      .nav { margin-bottom: 20px; }
      .nav a { color: var(--accent); text-decoration: none; margin-right: 15px; font-size: 12px; }
      .nav a:hover { text-decoration: underline; }
      
      .controls { background: #0a0f14; border: 1px solid #1e2732; border-radius: 6px; padding: 15px; margin: 15px 0; }
      .controls h3 { margin-top: 0; }
      
      .asset-list { font-size: 11px; }
      .asset-item { padding: 4px 8px; margin: 2px 0; border-radius: 4px; background: #0f1419; }
      .asset-item.missing { background: #2d1b1b; color: #ef4444; }
      .asset-item.found { background: #1b2d1f; color: #22c55e; }
      
      .loading-overlay {
        position: absolute; top: 0; left: 0; right: 0; bottom: 0;
        background: rgba(11, 13, 16, 0.8); display: flex; align-items: center; justify-content: center;
        flex-direction: column; z-index: 1000;
      }
      
      .spinner {
        width: 40px; height: 40px; border: 4px solid #1e2732;
        border-top: 4px solid var(--accent); border-radius: 50%; animation: spin 1s linear infinite;
      }
      @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
      
      #viewport { width: 100%; height: 100%; }
      
      /* Model Explorer Styles */
      .model-tree { border: 1px solid #1e2732; border-radius: 4px; max-height: 300px; overflow-y: auto; background: rgba(0,0,0,0.2); }
      .tree-item { display: block; padding: 4px 8px; cursor: pointer; border: none; background: none; color: var(--fg); width: 100%; text-align: left; font-size: 12px; }
      .tree-item:hover { background: rgba(112, 176, 255, 0.1); }
      .tree-item.selected { background: rgba(112, 176, 255, 0.2); color: var(--accent); }
      .tree-item.equipment { color: #22c55e; font-weight: bold; }
      .tree-indent { margin-left: 16px; }
      .transform-controls { margin-top: 10px; }
      .transform-group { margin-bottom: 15px; padding: 10px; border: 1px solid #1e2732; border-radius: 4px; background: rgba(0,0,0,0.1); }
      .transform-row { display: flex; gap: 3px; margin-bottom: 5px; align-items: center; flex-wrap: wrap; }
      .transform-label { width: 15px; font-size: 10px; color: var(--muted); flex-shrink: 0; }
      .transform-input { width: 50px; flex-shrink: 0; padding: 2px 3px; background: #1e2732; border: 1px solid #2a3441; color: var(--fg); font-size: 10px; }
      .reset-btn { padding: 2px 6px; font-size: 10px; background: #ef4444; color: white; border: none; cursor: pointer; }
      .reset-btn:hover { opacity: 0.8; }
      
      .camera-controls { 
        position: absolute; top: 10px; right: 10px; background: rgba(18, 22, 29, 0.9); 
        padding: 10px; border-radius: 6px; font-size: 11px; color: var(--muted);
      }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/fflate@0.7.4/umd/index.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/FBXLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  </head>
  <body>
    <div class="container">
      <div class="sidebar">
        <div class="nav">
          <a href="/">← QA Viewer</a>
          <a href="/build.html">Build</a>
          <a href="/preview.html">3D Preview</a>
        </div>
        
        <h1>3D Model Preview</h1>
        
        <div class="form-group">
          <label>Character:</label>
          <select id="characterSelect">
            <option value="samples/characters/warrior.json">Warrior</option>
          </select>
        </div>
        
        <button id="loadModel">Load Model</button>
        
        <div id="status"></div>
        
        <div class="controls">
          <h3>View Controls</h3>
          <button id="resetCamera">Reset Camera</button>
          <button id="toggleWireframe">Toggle Wireframe</button>
          
          <div class="form-group">
            <label>Background:</label>
            <select id="backgroundSelect">
              <option value="dark">Dark</option>
              <option value="light">Light</option>
              <option value="grid">Grid</option>
            </select>
          </div>
        </div>
        
        <div class="controls">
          <h3>Animation Controls</h3>
          <div class="form-group">
            <label>Animation:</label>
            <select id="animationSelect" disabled>
              <option value="">No animations loaded</option>
            </select>
          </div>
          <button id="playAnimation" disabled>Play</button>
          <button id="pauseAnimation" disabled>Pause</button>
          <button id="stopAnimation" disabled>Stop</button>
          
          <div class="form-group">
            <label>Speed:</label>
            <input type="range" id="animationSpeed" min="0.1" max="3" step="0.1" value="1" disabled style="width: 100%;">
            <span id="speedValue">1.0x</span>
          </div>
        </div>
        
        <div class="controls">
          <h3>Model Info</h3>
          <div id="modelInfo">No model loaded</div>
        </div>
        
        <div class="controls">
          <h3>Textures</h3>
          <div class="form-group">
            <label>Albedo Texture:</label>
            <select id="albedoSelect">
              <option value="">Default</option>
            </select>
          </div>
          <div class="form-group">
            <label>Normal Texture:</label>
            <select id="normalSelect">
              <option value="">Default</option>
            </select>
          </div>
          <button id="applyTextures" disabled>Apply Textures</button>
        </div>
        
        <div class="controls">
          <h3>Equipment</h3>
          <div id="equipmentList">No equipment loaded</div>
          <button id="applyEquipment" disabled>Apply Equipment</button>
        </div>
        
        <div class="controls">
          <h3>Assets Status</h3>
          <div id="assetStatus" class="asset-list">Click "Load Model" to check assets</div>
        </div>
      </div>
      
      <div class="viewport">
        <div id="viewport"></div>
        <div class="camera-controls">
          <strong>Camera Controls:</strong><br>
          Left click: Rotate<br>
          Right click: Pan<br>
          Scroll: Zoom
        </div>
        <div id="loadingOverlay" class="loading-overlay" style="display: none;">
          <div class="spinner"></div>
          <p style="margin-top: 20px;">Loading 3D model...</p>
        </div>
      </div>
      
      <div class="right-sidebar">
        <h2>Model Explorer</h2>
        
        <div class="controls">
          <h3>Scene Hierarchy</h3>
          <div id="modelTree" class="model-tree">
            <div style="padding: 20px; text-align: center; color: var(--muted);">
              Load a model to explore its structure
            </div>
          </div>
        </div>
        
        <div class="controls">
          <h3>Transform Controls</h3>
          <div id="transformControls" class="transform-controls">
            <div style="padding: 20px; text-align: center; color: var(--muted);">
              Select an object to edit transforms
            </div>
          </div>
        </div>
        
        <div class="controls">
          <h3>Object Properties</h3>
          <div id="objectProperties">
            <div style="padding: 20px; text-align: center; color: var(--muted);">
              Select an object to view properties
            </div>
          </div>
        </div>
      </div>
    </div>

    <script>
      let scene, camera, renderer, controls, model, mixer, clock, gltfLoader;
      let currentCharacter = null;
      let animations = [];
      let currentAction = null;
      let selectedObject = null;
      let equipmentObjects = new Map(); // Track equipment objects
      
      const ui = {
        characterSelect: document.getElementById('characterSelect'),
        loadModel: document.getElementById('loadModel'),
        status: document.getElementById('status'),
        modelInfo: document.getElementById('modelInfo'),
        assetStatus: document.getElementById('assetStatus'),
        resetCamera: document.getElementById('resetCamera'),
        toggleWireframe: document.getElementById('toggleWireframe'),
        backgroundSelect: document.getElementById('backgroundSelect'),
        animationSelect: document.getElementById('animationSelect'),
        playAnimation: document.getElementById('playAnimation'),
        pauseAnimation: document.getElementById('pauseAnimation'),
        stopAnimation: document.getElementById('stopAnimation'),
        animationSpeed: document.getElementById('animationSpeed'),
        speedValue: document.getElementById('speedValue'),
        albedoSelect: document.getElementById('albedoSelect'),
        normalSelect: document.getElementById('normalSelect'),
        applyTextures: document.getElementById('applyTextures'),
        equipmentList: document.getElementById('equipmentList'),
        applyEquipment: document.getElementById('applyEquipment'),
        viewport: document.getElementById('viewport'),
        loadingOverlay: document.getElementById('loadingOverlay'),
        modelTree: document.getElementById('modelTree'),
        transformControls: document.getElementById('transformControls'),
        objectProperties: document.getElementById('objectProperties')
      };

      function showStatus(message, type = 'success') {
        ui.status.innerHTML = `<div class="status ${type}">${message}</div>`;
      }

      function initThreeJS() {
        // Scene
        scene = new THREE.Scene();
        
        // Camera
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 1.6, 3);
        
        // Renderer
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(ui.viewport.offsetWidth, ui.viewport.offsetHeight);
        renderer.setClearColor(0x0b0d10);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        ui.viewport.appendChild(renderer.domElement);
        
        // Controls
        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.target.set(0, 1, 0);
        
        // Lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(5, 10, 5);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.setScalar(2048);
        scene.add(directionalLight);
        
        const fillLight = new THREE.DirectionalLight(0x4488ff, 0.3);
        fillLight.position.set(-5, 5, -5);
        scene.add(fillLight);
        
        // Ground plane
        const groundGeometry = new THREE.PlaneGeometry(10, 10);
        const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x1a1f26 });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);
        
        // Clock for animations
        clock = new THREE.Clock();
        
        // Initialize loaders
        gltfLoader = new THREE.GLTFLoader();
        
        // Resize handler
        window.addEventListener('resize', onWindowResize);
        
        animate();
      }

      function onWindowResize() {
        camera.aspect = ui.viewport.offsetWidth / ui.viewport.offsetHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(ui.viewport.offsetWidth, ui.viewport.offsetHeight);
      }

      function animate() {
        requestAnimationFrame(animate);
        
        controls.update();
        
        if (mixer) {
          mixer.update(clock.getDelta());
        }
        
        renderer.render(scene, camera);
      }

      async function inspectCharacter(characterPath) {
        try {
          const response = await fetch('/api/content/inspect', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ characterPath })
          });
          
          const result = await response.json();
          
          if (result.success) {
            currentCharacter = result;
            updateAssetStatus(result.assets);
            return result;
          } else {
            throw new Error(result.message || 'Failed to inspect character');
          }
        } catch (error) {
          showStatus(`Inspection failed: ${error.message}`, 'error');
          return null;
        }
      }

      function updateAssetStatus(assets) {
        let html = '';
        
        if (assets.rig) {
          const status = assets.rig.exists ? 'found' : 'missing';
          const icon = assets.rig.exists ? '✅' : '❌';
          html += `<div class="asset-item ${status}">${icon} Rig: ${assets.rig.path}</div>`;
        }
        
        for (const anim of assets.animations) {
          const status = anim.exists ? 'found' : 'missing';
          const icon = anim.exists ? '✅' : '❌';
          html += `<div class="asset-item ${status}">${icon} ${anim.name} (${anim.frames}f)</div>`;
        }
        
        for (const tex of assets.textures) {
          const status = tex.exists ? 'found' : 'missing';
          const icon = tex.exists ? '✅' : '❌';
          html += `<div class="asset-item ${status}">${icon} ${tex.type}</div>`;
        }
        
        for (const equip of assets.equipment) {
          const status = equip.exists ? 'found' : 'missing';
          const icon = equip.exists ? '✅' : '❌';
          html += `<div class="asset-item ${status}">${icon} ${equip.mount}</div>`;
        }
        
        ui.assetStatus.innerHTML = html || 'No assets found';
      }

      async function loadModel() {
        const characterPath = ui.characterSelect.value;
        
        showStatus('Inspecting character...', 'warning');
        ui.loadingOverlay.style.display = 'flex';
        
        const characterData = await inspectCharacter(characterPath);
        if (!characterData) return;
        
        // Clear previous model
        if (model) {
          scene.remove(model);
          model = null;
        }
        if (mixer) {
          mixer = null;
        }
        
        if (!characterData.assets.rig || !characterData.assets.rig.exists) {
          showStatus('No rig file found', 'error');
          ui.loadingOverlay.style.display = 'none';
          return;
        }
        
        showStatus('Loading 3D model...', 'warning');
        
        try {
          const rigPath = `/content/rigs/${characterData.assets.rig.path.split('/').pop()}`;
          console.log('Loading model from:', rigPath);
          
          if (rigPath.endsWith('.fbx')) {
            console.log('Using FBXLoader...');
            const loader = new THREE.FBXLoader();
            model = await new Promise((resolve, reject) => {
              loader.load(
                rigPath, 
                (object) => {
                  console.log('FBX loaded successfully:', object);
                  resolve(object);
                },
                (progress) => {
                  console.log('Loading progress:', progress);
                },
                (error) => {
                  console.error('FBX loading error:', error);
                  reject(error);
                }
              );
            });
          } else if (rigPath.endsWith('.glb') || rigPath.endsWith('.gltf')) {
            console.log('Using GLTFLoader...');
            const loader = new THREE.GLTFLoader();
            const gltf = await new Promise((resolve, reject) => {
              loader.load(
                rigPath, 
                (gltf) => {
                  console.log('GLTF loaded successfully:', gltf);
                  resolve(gltf);
                },
                (progress) => {
                  console.log('Loading progress:', progress);
                },
                (error) => {
                  console.error('GLTF loading error:', error);
                  reject(error);
                }
              );
            });
            model = gltf.scene;
          } else {
            throw new Error('Unsupported model format');
          }
          
          // Setup model
          model.scale.setScalar(0.01); // Scale down if needed
          model.traverse(child => {
            if (child.isMesh) {
              child.castShadow = true;
              child.receiveShadow = true;
            }
          });
          
          scene.add(model);
          
          // Setup animation mixer
          mixer = new THREE.AnimationMixer(model);
          
          if (model.animations && model.animations.length > 0) {
            console.log('Found embedded animations in rig:', model.animations);
            animations = [...model.animations]; // Copy embedded animations
            
            // Map animation names to more readable names if possible
            animations.forEach((anim, index) => {
              console.log(`Embedded Animation ${index}: "${anim.name}" (duration: ${anim.duration}s)`);
              
              // Try to map generic names to specific animation types
              if (anim.name.toLowerCase().includes('walk') || anim.name.includes('Walk')) {
                anim.displayName = 'walk (embedded)';
              } else if (anim.name.toLowerCase().includes('run') || anim.name.includes('Run')) {
                anim.displayName = 'run (embedded)';
              } else if (anim.name.toLowerCase().includes('attack') || anim.name.includes('Attack')) {
                anim.displayName = 'attack_slash (embedded)';
              } else if (anim.name.toLowerCase().includes('hit') || anim.name.includes('Hit')) {
                anim.displayName = 'hit (embedded)';
              } else if (anim.name.toLowerCase().includes('die') || anim.name.toLowerCase().includes('death')) {
                anim.displayName = 'die (embedded)';
              } else {
                anim.displayName = `${anim.name || `Animation ${index + 1}`} (embedded)`;
              }
              anim.isEmbedded = true;
            });
          } else {
            console.log('No embedded animations found in rig');
            animations = [];
          }
          
          // Always try to load additional separate animation files
          console.log('Loading additional asset-defined animations...');
          await loadAnimations(characterData);
          
          // Update model info
          let info = `<strong>${characterData.character.name}</strong><br>`;
          info += `Vertices: ${getVertexCount(model)}<br>`;
          info += `Materials: ${getMaterialCount(model)}<br>`;
          info += `Bones: ${getBoneCount(model)}<br>`;
          info += `Animations: ${animations.length}`;
          ui.modelInfo.innerHTML = info;
          
          // Populate textures and equipment
          populateAssetControls(characterData);
          
          // Add debug cube to verify 3D rendering is working
          addDebugCube();
          
          // Build model explorer tree
          buildModelTree();
          
          showStatus('Model loaded successfully!', 'success');
          
        } catch (error) {
          showStatus(`Failed to load model: ${error.message}`, 'error');
          console.error('Model loading error:', error);
        }
        
        ui.loadingOverlay.style.display = 'none';
      }

      function getVertexCount(object) {
        let count = 0;
        object.traverse(child => {
          if (child.isMesh && child.geometry) {
            count += child.geometry.attributes.position.count;
          }
        });
        return count.toLocaleString();
      }

      function getMaterialCount(object) {
        const materials = new Set();
        object.traverse(child => {
          if (child.isMesh && child.material) {
            if (Array.isArray(child.material)) {
              child.material.forEach(mat => materials.add(mat.uuid));
            } else {
              materials.add(child.material.uuid);
            }
          }
        });
        return materials.size;
      }

      function getBoneCount(object) {
        let boneCount = 0;
        object.traverse(child => {
          if (child.isBone) boneCount++;
        });
        return boneCount;
      }

      async function loadAnimations(characterData) {
        if (!characterData.assets.animations || !mixer) {
          console.log('No animations to load or mixer not ready');
          return;
        }
        
        console.log('Available animations:', characterData.assets.animations);
        
        try {
          for (const animAsset of characterData.assets.animations) {
            console.log(`Processing animation: ${animAsset.name}, exists: ${animAsset.exists}`);
            
            if (!animAsset.exists) {
              console.log(`Skipping missing animation: ${animAsset.name}`);
              continue;
            }
            
            const animPath = `/content/anims/${animAsset.path.split('/').pop()}`;
            console.log('Loading animation from:', animPath);
            
            try {
              if (animPath.endsWith('.fbx')) {
                const loader = new THREE.FBXLoader();
                const animObject = await new Promise((resolve, reject) => {
                  loader.load(
                    animPath, 
                    (object) => {
                      console.log(`Animation loaded: ${animAsset.name}`, object);
                      resolve(object);
                    },
                    (progress) => {
                      console.log(`Loading ${animAsset.name}:`, progress.loaded / progress.total * 100, '%');
                    },
                    (error) => {
                      console.error(`Failed to load ${animAsset.name}:`, error);
                      reject(error);
                    }
                  );
                });
                
                if (animObject.animations && animObject.animations.length > 0) {
                  console.log(`Found ${animObject.animations.length} animation clips in ${animAsset.name}`);
                  animObject.animations.forEach((anim, index) => {
                    // Set display name and mark as asset-defined
                    anim.displayName = animAsset.name;
                    anim.originalName = anim.name;
                    anim.isEmbedded = false;
                    anim.assetInfo = animAsset;
                    
                    animations.push(anim);
                    console.log(`Added asset animation: ${animAsset.name} (duration: ${anim.duration}s)`);
                  });
                } else {
                  console.warn(`No animation data found in ${animAsset.name}`);
                }
              }
            } catch (animError) {
              console.error(`Error loading ${animAsset.name}:`, animError);
            }
          }
          
          console.log(`Total animations loaded: ${animations.length}`);
          
          // Always set up controls - either with real animations or placeholders
          if (animations.length > 0) {
            setupAnimationControls();
            const embeddedCount = animations.filter(a => a.isEmbedded).length;
            const assetCount = animations.filter(a => !a.isEmbedded).length;
            showStatus(`Loaded ${animations.length} animations (${embeddedCount} embedded, ${assetCount} from assets)`, 'success');
          } else {
            // Create placeholder animations based on character data
            createPlaceholderAnimations(characterData);
          }
        } catch (error) {
          console.error('Animation loading error:', error);
          showStatus('Animation loading failed', 'error');
        }
      }

      function createPlaceholderAnimations(characterData) {
        console.log('Creating placeholder animations...');
        
        // Create basic placeholder animations based on character animation data
        ui.animationSelect.innerHTML = '<option value="">Select animation...</option>';
        
        if (characterData.assets.animations && characterData.assets.animations.length > 0) {
          characterData.assets.animations.forEach((animAsset, index) => {
            const option = document.createElement('option');
            option.value = index;
            option.textContent = `${animAsset.name} (${animAsset.exists ? 'placeholder' : 'missing'})`;
            if (!animAsset.exists) {
              option.style.color = '#ef4444';
              option.disabled = true;
            }
            ui.animationSelect.appendChild(option);
          });
          
          showStatus('Animation files not loaded - showing placeholders', 'warning');
        } else {
          ui.animationSelect.innerHTML = '<option value="">No animations defined</option>';
          showStatus('No animations defined in character', 'error');
        }
        
        // Enable basic controls
        ui.animationSelect.disabled = false;
        ui.playAnimation.disabled = true;
        ui.pauseAnimation.disabled = true;
        ui.stopAnimation.disabled = true;
        ui.animationSpeed.disabled = true;
      }

      function setupAnimationControls() {
        console.log('Setting up animation controls for', animations.length, 'animations');
        
        // Populate animation dropdown
        ui.animationSelect.innerHTML = '<option value="">Select animation...</option>';
        animations.forEach((anim, index) => {
          const option = document.createElement('option');
          option.value = index;
          option.textContent = anim.displayName || anim.name || `Animation ${index + 1}`;
          ui.animationSelect.appendChild(option);
          console.log(`Added to dropdown: ${option.textContent}`);
        });
        
        // Enable controls
        ui.animationSelect.disabled = false;
        ui.playAnimation.disabled = false;
        ui.pauseAnimation.disabled = false;
        ui.stopAnimation.disabled = false;
        ui.animationSpeed.disabled = false;
        
        console.log('Animation controls enabled');
      }

      function playSelectedAnimation() {
        const selectedIndex = ui.animationSelect.value;
        if (selectedIndex === '' || !mixer || !animations[selectedIndex]) return;
        
        // Stop current action
        if (currentAction) {
          currentAction.stop();
        }
        
        // Create and play new action
        const animation = animations[selectedIndex];
        currentAction = mixer.clipAction(animation);
        currentAction.setLoop(THREE.LoopRepeat);
        currentAction.timeScale = parseFloat(ui.animationSpeed.value);
        currentAction.play();
        
        showStatus(`Playing: ${animation.name || 'Animation'}`, 'success');
      }

      function pauseAnimation() {
        if (currentAction && currentAction.isRunning()) {
          currentAction.paused = !currentAction.paused;
          showStatus(currentAction.paused ? 'Animation paused' : 'Animation resumed', 'success');
        }
      }

      function stopAnimation() {
        if (currentAction) {
          currentAction.stop();
          showStatus('Animation stopped', 'success');
        }
      }

      function updateAnimationSpeed() {
        const speed = parseFloat(ui.animationSpeed.value);
        ui.speedValue.textContent = speed.toFixed(1) + 'x';
        if (currentAction) {
          currentAction.timeScale = speed;
        }
      }

      // Event listeners
      ui.loadModel.addEventListener('click', loadModel);
      
      ui.resetCamera.addEventListener('click', () => {
        camera.position.set(0, 1.6, 3);
        controls.target.set(0, 1, 0);
        controls.update();
      });
      
      ui.toggleWireframe.addEventListener('click', () => {
        if (model) {
          model.traverse(child => {
            if (child.isMesh && child.material) {
              if (Array.isArray(child.material)) {
                child.material.forEach(mat => mat.wireframe = !mat.wireframe);
              } else {
                child.material.wireframe = !child.material.wireframe;
              }
            }
          });
        }
      });
      
      ui.backgroundSelect.addEventListener('change', (e) => {
        switch (e.target.value) {
          case 'dark':
            renderer.setClearColor(0x0b0d10);
            break;
          case 'light':
            renderer.setClearColor(0xf0f0f0);
            break;
          case 'grid':
            renderer.setClearColor(0x1a1f26);
            break;
        }
      });
      
      // Animation controls
      ui.animationSelect.addEventListener('change', playSelectedAnimation);
      ui.playAnimation.addEventListener('click', playSelectedAnimation);
      ui.pauseAnimation.addEventListener('click', pauseAnimation);
      ui.stopAnimation.addEventListener('click', stopAnimation);
      ui.animationSpeed.addEventListener('input', updateAnimationSpeed);
      
      // Asset controls
      ui.applyTextures.addEventListener('click', applyTextures);
      ui.applyEquipment.addEventListener('click', applyEquipment);
      
      function populateAssetControls(characterData) {
        // Populate texture selectors
        ui.albedoSelect.innerHTML = '<option value="">Default</option>';
        ui.normalSelect.innerHTML = '<option value="">Default</option>';
        
        if (characterData.assets.textures) {
          characterData.assets.textures.forEach(texture => {
            if (texture.exists) {
              const option = document.createElement('option');
              option.value = texture.path;
              option.textContent = `${texture.type} (${texture.path})`;
              
              if (texture.type === 'albedo') {
                ui.albedoSelect.appendChild(option);
              } else if (texture.type === 'normal') {
                ui.normalSelect.appendChild(option);
              }
            }
          });
        }
        
        // Populate equipment list
        if (characterData.assets.equipment && characterData.assets.equipment.length > 0) {
          let equipmentHtml = '';
          characterData.assets.equipment.forEach((item, index) => {
            const status = item.exists ? 'found' : 'missing';
            const statusText = item.exists ? '✓' : '✗';
            equipmentHtml += `<div class="asset-item ${status}">
              <label style="display: flex; align-items: center; cursor: pointer; margin: 0;">
                <input type="checkbox" id="equipment_${index}" ${item.exists ? '' : 'disabled'} style="margin-right: 8px;">
                <span>${statusText} ${item.mount}: ${item.path.split('/').pop()}</span>
              </label>
            </div>`;
          });
          ui.equipmentList.innerHTML = equipmentHtml;
        } else {
          ui.equipmentList.innerHTML = 'No equipment defined';
        }
        
        // Enable controls
        ui.applyTextures.disabled = false;
        ui.applyEquipment.disabled = false;
      }
      
      async function applyTextures() {
        if (!model) {
          showStatus('No model loaded', 'error');
          return;
        }
        
        const albedoPath = ui.albedoSelect.value;
        const normalPath = ui.normalSelect.value;
        
        try {
          const textureLoader = new THREE.TextureLoader();
          
          // Apply textures to all mesh materials
          model.traverse(child => {
            if (child.isMesh && child.material) {
              const materials = Array.isArray(child.material) ? child.material : [child.material];
              
              materials.forEach(material => {
                if (material.isMeshStandardMaterial || material.isMeshPhongMaterial) {
                  // Apply albedo texture
                  if (albedoPath) {
                    let albedoUrl;
                    if (albedoPath.startsWith('../../content/')) {
                      // Path is already absolute from repo root
                      albedoUrl = albedoPath.replace('../../', '/');
                    } else {
                      // Legacy relative path
                      const cleanPath = albedoPath.replace(/^\.\//, '');
                      albedoUrl = `/content/characters/${cleanPath}`;
                    }
                    textureLoader.load(albedoUrl, 
                      texture => {
                        material.map = texture;
                        material.needsUpdate = true;
                        console.log('Applied albedo texture:', albedoUrl);
                      },
                      undefined,
                      error => console.error('Failed to load albedo texture:', error)
                    );
                  } else {
                    material.map = null;
                    material.needsUpdate = true;
                  }
                  
                  // Apply normal texture
                  if (normalPath) {
                    let normalUrl;
                    if (normalPath.startsWith('../../content/')) {
                      // Path is already absolute from repo root
                      normalUrl = normalPath.replace('../../', '/');
                    } else {
                      // Legacy relative path
                      const cleanPath = normalPath.replace(/^\.\//, '');
                      normalUrl = `/content/characters/${cleanPath}`;
                    }
                    textureLoader.load(normalUrl,
                      texture => {
                        material.normalMap = texture;
                        material.needsUpdate = true;
                        console.log('Applied normal texture:', normalUrl);
                      },
                      undefined,
                      error => console.error('Failed to load normal texture:', error)
                    );
                  } else {
                    material.normalMap = null;
                    material.needsUpdate = true;
                  }
                }
              });
            }
          });
          
          showStatus('Textures applied successfully', 'success');
          
        } catch (error) {
          showStatus(`Failed to apply textures: ${error.message}`, 'error');
          console.error('Texture application error:', error);
        }
      }
      
      async function applyEquipment() {
        if (!model || !currentCharacter) {
          showStatus('No model loaded', 'error');
          return;
        }
        
        try {
          // Remove existing equipment
          const existingEquipment = scene.children.filter(child => child.userData.isEquipment);
          existingEquipment.forEach(item => scene.remove(item));
          
          // Clear equipment tracking
          equipmentObjects.clear();
          
          // Create simple equipment using basic Three.js geometry
          const equipmentItems = currentCharacter.assets.equipment;
          
          for (let i = 0; i < equipmentItems.length; i++) {
            const item = equipmentItems[i];
            const checkbox = document.getElementById(`equipment_${i}`);
            
            if (checkbox && checkbox.checked && item.exists) {
              let equipment;
              
              // Try to load GLTF model first, fallback to simple geometry
              try {
                // Build the full URL for the equipment item
                let equipmentUrl;
                const itemPath = item.item || item.path; // Use item.item first, fallback to item.path
                if (itemPath.startsWith('../../content/')) {
                  equipmentUrl = itemPath.replace('../../', '/');
                } else {
                  const cleanPath = itemPath.replace(/^\.\//, '');
                  equipmentUrl = `/content/characters/${cleanPath}`;
                }
                
                console.log(`Attempting to load equipment GLTF: ${equipmentUrl}`);
                console.log(`Equipment item data:`, item);
                
                // Load GLTF model
                const gltf = await new Promise((resolve, reject) => {
                  gltfLoader.load(
                    equipmentUrl,
                    resolve,
                    undefined,
                    reject
                  );
                });
                
                equipment = gltf.scene.clone();
                equipment.scale.setScalar(1.0); // Reset scale
                
                // Apply mount-specific positioning and scaling
                if (item.mount === 'hand_r') {
                  equipment.scale.setScalar(5.0); // Make sword much bigger
                  equipment.position.set(0, 1.0, 0); // Move it up from the hand
                  equipment.rotation.set(0, 0, 0); // Reset rotation
                } else if (item.mount === 'head') {
                  equipment.scale.setScalar(1.0);
                  equipment.position.set(0, 0, 0);
                } else if (item.mount === 'back') {
                  equipment.scale.setScalar(1.0);
                  equipment.position.set(0, 0, 0);
                }
                
                console.log(`Successfully loaded GLTF equipment for ${item.mount}`);
                
              } catch (gltfError) {
                console.warn(`Failed to load GLTF for ${item.mount}:`, gltfError);
                console.log(`Falling back to simple geometry for ${item.mount}`);
                
                // Fallback to simple geometry
                if (item.mount === 'head') {
                  // Golden helmet cube
                  const geometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
                  const material = new THREE.MeshBasicMaterial({ color: 0xffdd00 });
                  equipment = new THREE.Mesh(geometry, material);
                  equipment.position.set(0, 0.3, 0);
                } else if (item.mount === 'hand_r') {
                  // Silver sword rectangle - make it much more visible
                  const geometry = new THREE.BoxGeometry(0.2, 1.5, 0.2);
                  const material = new THREE.MeshBasicMaterial({ color: 0x00ccff });
                  equipment = new THREE.Mesh(geometry, material);
                  equipment.position.set(0.3, 0.5, 0);
                } else if (item.mount === 'back') {
                  // Red cape rectangle - make it much more visible
                  const geometry = new THREE.BoxGeometry(0.8, 1.0, 0.2);
                  const material = new THREE.MeshBasicMaterial({ color: 0xff3333 });
                  equipment = new THREE.Mesh(geometry, material);
                  equipment.position.set(0, 0, -0.5);
                }
              }
              
              if (equipment) {
                equipment.userData.isEquipment = true;
                equipment.userData.mount = item.mount;
                
                // Find attachment point on the model
                const attachmentPoint = findBoneByName(model, item.mount);
                if (attachmentPoint) {
                  attachmentPoint.add(equipment);
                  console.log(`Attached ${item.mount} equipment to bone ${attachmentPoint.name}`);
                } else {
                  // If no specific attachment point found, add to scene
                  scene.add(equipment);
                  console.log(`Added ${item.mount} equipment to scene (no attachment point found)`);
                }
                
                // Track equipment for model explorer
                equipmentObjects.set(item.mount, equipment);
              }
            }
          }
          
          // Rebuild model explorer tree to include equipment
          buildModelTree();
          
          showStatus('Equipment applied successfully', 'success');
          
        } catch (error) {
          showStatus(`Failed to apply equipment: ${error.message}`, 'error');
          console.error('Equipment application error:', error);
        }
      }
      
      function addDebugCube() {
        // Create a bright red cube for debugging
        const geometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
        const material = new THREE.MeshBasicMaterial({ color: 0xff0000 });
        const debugCube = new THREE.Mesh(geometry, material);
        
        // Position it next to the model
        debugCube.position.set(2, 1, 0);
        debugCube.userData.isDebug = true;
        
        scene.add(debugCube);
        console.log('Added debug cube at position (2, 1, 0)');
      }

      function findBoneByName(object, name) {
        let found = null;
        const searchTerms = {
          'hand_r': ['hand_r', 'righthand', 'hand.r', 'mixamorig:righthand', 'rhand', 'r_hand', 'hand_right'],
          'head': ['head', 'mixamorig:head', 'headtop', 'head_top'],
          'back': ['spine', 'spine2', 'spine1', 'mixamorig:spine', 'mixamorig:spine2', 'back', 'chest']
        };
        
        const terms = searchTerms[name.toLowerCase()] || [name];
        
        object.traverse(child => {
          if (child.isBone) {
            console.log('Found bone:', child.name);
            for (const term of terms) {
              if (child.name.toLowerCase().includes(term.toLowerCase())) {
                found = child;
                console.log(`Matched bone "${child.name}" for mount point "${name}"`);
                return;
              }
            }
          }
        });
        
        if (!found) {
          console.log(`No bone found for mount point "${name}". Available bones logged above.`);
        }
        
        return found;
      }
      
      // Model Explorer Functions
      function buildModelTree() {
        if (!model && !scene) {
          ui.modelTree.innerHTML = '<div style="padding: 20px; text-align: center; color: var(--muted);">Load a model to explore its structure</div>';
          return;
        }
        
        let html = '';
        
        // Add main model
        if (model) {
          html += buildTreeItem(model, 0, 'Model');
        }
        
        // Add equipment objects
        equipmentObjects.forEach((equipment, mountPoint) => {
          html += buildTreeItem(equipment, 0, `Equipment: ${mountPoint}`, true);
        });
        
        ui.modelTree.innerHTML = html;
      }
      
      function buildTreeItem(object, depth, customName = null, isEquipment = false) {
        const indent = 'tree-indent '.repeat(depth);
        const name = customName || object.name || object.type || 'Unnamed';
        const equipClass = isEquipment ? ' equipment' : '';
        const id = `tree_${object.uuid}`;
        
        let html = `<button class="tree-item ${indent}${equipClass}" data-object-id="${object.uuid}" id="${id}">`;
        html += `${'  '.repeat(depth)}${name}`;
        if (object.children && object.children.length > 0) {
          html += ` (${object.children.length} children)`;
        }
        html += '</button>';
        
        // Add children
        if (object.children) {
          object.children.forEach(child => {
            html += buildTreeItem(child, depth + 1);
          });
        }
        
        return html;
      }
      
      function selectObject(object) {
        // Clear previous selection
        document.querySelectorAll('.tree-item.selected').forEach(item => {
          item.classList.remove('selected');
        });
        
        // Highlight new selection
        if (object) {
          const treeItem = document.getElementById(`tree_${object.uuid}`);
          if (treeItem) {
            treeItem.classList.add('selected');
          }
        }
        
        selectedObject = object;
        updateTransformControls();
        updateObjectProperties();
      }
      
      function updateTransformControls() {
        if (!selectedObject) {
          ui.transformControls.innerHTML = '<div style="padding: 20px; text-align: center; color: var(--muted);">Select an object to edit transforms</div>';
          return;
        }
        
        const pos = selectedObject.position;
        const rot = selectedObject.rotation;
        const scale = selectedObject.scale;
        
        ui.transformControls.innerHTML = `
          <div class="transform-group">
            <h4 style="margin: 0 0 5px 0; color: var(--accent); font-size: 12px;">Position</h4>
            <div class="transform-row">
              <span class="transform-label">X</span>
              <input type="number" class="transform-input" id="pos-x" value="${pos.x.toFixed(2)}" step="0.1">
              <span class="transform-label">Y</span>
              <input type="number" class="transform-input" id="pos-y" value="${pos.y.toFixed(2)}" step="0.1">
            </div>
            <div class="transform-row">
              <span class="transform-label">Z</span>
              <input type="number" class="transform-input" id="pos-z" value="${pos.z.toFixed(2)}" step="0.1">
              <button class="reset-btn" onclick="resetPosition()">Reset</button>
            </div>
          </div>
          
          <div class="transform-group">
            <h4 style="margin: 0 0 5px 0; color: var(--accent); font-size: 12px;">Rotation (degrees)</h4>
            <div class="transform-row">
              <span class="transform-label">X</span>
              <input type="number" class="transform-input" id="rot-x" value="${(rot.x * 180/Math.PI).toFixed(0)}" step="5">
              <span class="transform-label">Y</span>
              <input type="number" class="transform-input" id="rot-y" value="${(rot.y * 180/Math.PI).toFixed(0)}" step="5">
            </div>
            <div class="transform-row">
              <span class="transform-label">Z</span>
              <input type="number" class="transform-input" id="rot-z" value="${(rot.z * 180/Math.PI).toFixed(0)}" step="5">
              <button class="reset-btn" onclick="resetRotation()">Reset</button>
            </div>
          </div>
          
          <div class="transform-group">
            <h4 style="margin: 0 0 5px 0; color: var(--accent); font-size: 12px;">Scale</h4>
            <div class="transform-row">
              <span class="transform-label">All</span>
              <input type="number" class="transform-input" id="scale-all" value="${scale.x.toFixed(1)}" step="0.5" min="0.1" onchange="updateUniformScale()">
              <button class="reset-btn" onclick="setScale(1,1,1)">1.0</button>
            </div>
            <div class="transform-row">
              <span class="transform-label">X</span>
              <input type="number" class="transform-input" id="scale-x" value="${scale.x.toFixed(1)}" step="0.1" min="0.1">
              <span class="transform-label">Y</span>
              <input type="number" class="transform-input" id="scale-y" value="${scale.y.toFixed(1)}" step="0.1" min="0.1">
            </div>
            <div class="transform-row">
              <span class="transform-label">Z</span>
              <input type="number" class="transform-input" id="scale-z" value="${scale.z.toFixed(1)}" step="0.1" min="0.1">
              <button class="reset-btn" onclick="resetScale()">Reset</button>
            </div>
          </div>
        `;
        
        // Add event listeners for real-time updates
        ['pos-x', 'pos-y', 'pos-z'].forEach(id => {
          document.getElementById(id).addEventListener('input', updatePosition);
        });
        ['rot-x', 'rot-y', 'rot-z'].forEach(id => {
          document.getElementById(id).addEventListener('input', updateRotation);
        });
        ['scale-x', 'scale-y', 'scale-z'].forEach(id => {
          document.getElementById(id).addEventListener('input', updateScale);
        });
      }
      
      function updateObjectProperties() {
        if (!selectedObject) {
          ui.objectProperties.innerHTML = '<div style="padding: 20px; text-align: center; color: var(--muted);">Select an object to view properties</div>';
          return;
        }
        
        const isEquipment = selectedObject.userData.isEquipment;
        const mountPoint = selectedObject.userData.mount;
        
        ui.objectProperties.innerHTML = `
          <div style="font-size: 12px; line-height: 1.4;">
            <div><strong>Name:</strong> ${selectedObject.name || 'Unnamed'}</div>
            <div><strong>Type:</strong> ${selectedObject.type}</div>
            ${isEquipment ? `<div><strong>Mount:</strong> ${mountPoint}</div>` : ''}
            <div><strong>UUID:</strong> ${selectedObject.uuid.substring(0, 8)}...</div>
            <div><strong>Children:</strong> ${selectedObject.children.length}</div>
            ${selectedObject.geometry ? `<div><strong>Vertices:</strong> ${selectedObject.geometry.attributes.position.count}</div>` : ''}
            ${selectedObject.material ? `<div><strong>Material:</strong> ${selectedObject.material.type}</div>` : ''}
          </div>
        `;
      }
      
      // Transform helper functions
      function updatePosition() {
        if (!selectedObject) return;
        const x = parseFloat(document.getElementById('pos-x').value) || 0;
        const y = parseFloat(document.getElementById('pos-y').value) || 0;
        const z = parseFloat(document.getElementById('pos-z').value) || 0;
        selectedObject.position.set(x, y, z);
      }
      
      function updateRotation() {
        if (!selectedObject) return;
        const x = (parseFloat(document.getElementById('rot-x').value) || 0) * Math.PI / 180;
        const y = (parseFloat(document.getElementById('rot-y').value) || 0) * Math.PI / 180;
        const z = (parseFloat(document.getElementById('rot-z').value) || 0) * Math.PI / 180;
        selectedObject.rotation.set(x, y, z);
      }
      
      function updateScale() {
        if (!selectedObject) return;
        const x = parseFloat(document.getElementById('scale-x').value) || 1;
        const y = parseFloat(document.getElementById('scale-y').value) || 1;
        const z = parseFloat(document.getElementById('scale-z').value) || 1;
        selectedObject.scale.set(x, y, z);
        document.getElementById('scale-all').value = x.toFixed(3);
      }
      
      function updateUniformScale() {
        if (!selectedObject) return;
        const value = parseFloat(document.getElementById('scale-all').value) || 1;
        setScale(value, value, value);
      }
      
      function setScale(x, y, z) {
        if (!selectedObject) return;
        selectedObject.scale.set(x, y, z);
        if (document.getElementById('scale-x')) {
          document.getElementById('scale-x').value = x.toFixed(3);
          document.getElementById('scale-y').value = y.toFixed(3);
          document.getElementById('scale-z').value = z.toFixed(3);
          document.getElementById('scale-all').value = x.toFixed(3);
        }
      }
      
      function resetPosition() {
        if (!selectedObject) return;
        selectedObject.position.set(0, 0, 0);
        updateTransformControls();
      }
      
      function resetRotation() {
        if (!selectedObject) return;
        selectedObject.rotation.set(0, 0, 0);
        updateTransformControls();
      }
      
      function resetScale() {
        if (!selectedObject) return;
        selectedObject.scale.set(1, 1, 1);
        updateTransformControls();
      }
      
      // Add event listener for tree item clicks
      document.addEventListener('click', (e) => {
        if (e.target.classList.contains('tree-item')) {
          const objectId = e.target.dataset.objectId;
          if (objectId) {
            // Find object by UUID
            let targetObject = null;
            
            // Search in model
            if (model) {
              model.traverse(obj => {
                if (obj.uuid === objectId) targetObject = obj;
              });
            }
            
            // Search in equipment
            if (!targetObject) {
              equipmentObjects.forEach(equipment => {
                equipment.traverse(obj => {
                  if (obj.uuid === objectId) targetObject = obj;
                });
              });
            }
            
            // Search in scene
            if (!targetObject) {
              scene.traverse(obj => {
                if (obj.uuid === objectId) targetObject = obj;
              });
            }
            
            if (targetObject) {
              selectObject(targetObject);
            }
          }
        }
      });
      
      // Initialize
      initThreeJS();
      showStatus('Ready to preview 3D models', 'success');
    </script>
  </body>
</html>